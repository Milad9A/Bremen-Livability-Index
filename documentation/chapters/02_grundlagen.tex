% !TEX root = ../main.tex
% ============================================================
\chapter{Grundlagen}
\label{ch:grundlagen}
% ============================================================

\section{Lebensqualität und urbane Indizes}

Der Begriff \textit{Lebensqualität} umfasst eine Vielzahl objektiv messbarer und
subjektiv empfundener Dimensionen, darunter Gesundheitsversorgung, Bildung,
Sicherheit, Umweltqualität und infrastrukturelle Erreichbarkeit
\parencite{economist_gla}. Internationale Ansätze wie der \textit{Global
  Liveability Index} (EIU) oder der \textit{Quality of Living Index} (Mercer)
bewerten Städte auf Grundlage makroskopischer Indikatoren
\parencite{mercer2019}. Beide operieren auf Stadtebene und bieten keine
feinräumige Auflösung innerhalb einer Stadt.

Ziel des Bremen Livability Index ist es, einen \textbf{mikroskaligen}
Lebensqualitätsindex zu realisieren, der für \textit{jeden beliebigen Punkt}
innerhalb des Stadtgebiets einen Score berechnet. Dazu werden
\acrfull{gis}-Methoden eingesetzt, um die räumliche Nähe zu positiven und
negativen Infrastrukturmerkmalen quantitativ zu erfassen.

\section{Geoinformationssysteme und räumliche Datenbanken}
\label{sec:gis_grundlagen}

Ein \acrfull{gis} dient der Erfassung, Verwaltung, Analyse und Darstellung
raumbezogener Daten. Im Kontext dieses Projekts werden insbesondere zwei
Fähigkeiten benötigt:

\begin{itemize}
  \item \textbf{Räumliche Abfragen}: Bestimmung aller Objekte innerhalb eines
        definierten Radius um einen Punkt (\textit{proximity queries}).
  \item \textbf{Distanzberechnung}: Berechnung der ellipsoidalen Entfernung
        zwischen geographischen Koordinaten unter Berücksichtigung der
        Erdkrümmung.
\end{itemize}

Die Datenbank PostgreSQL bietet mit der Erweiterung \textbf{PostGIS}
\parencite{postgis_docs} eine leistungsfähige räumliche Datenbanklösung.
PostGIS unterstützt sowohl den Datentyp \texttt{GEOMETRY} (kartesische Ebene)
als auch \texttt{GEOGRAPHY} (ellipsoidale Berechnung auf dem WGS\,84-Ellipsoid).
Für die exakte Entfernungsberechnung in Metern wird in diesem Projekt
ausschließlich der Typ \texttt{GEOGRAPHY} verwendet.

Zentrale PostGIS-Funktionen im Projekt sind
\texttt{ST\_DWithin} (Proximity-Prüfung mit GiST-Index),
\texttt{ST\_Distance} (ellipsoidale Entfernung in Metern),
\texttt{ST\_MakePoint}/\texttt{ST\_SetSRID} (Punkterzeugung mit \acrshort{crs}-Zuweisung)
und \texttt{ST\_AsGeoJSON} (Konvertierung für das Frontend).

\section{Koordinatenreferenzsystem}
\label{sec:crs}

Das gesamte Projekt verwendet durchgängig \textbf{EPSG:4326 (\acrshort{wgs84})}
als einziges \acrlong{crs} -- für die Datenbank, die \acrshort{api}-Ein- und
Ausgabe sowie alle \acrshort{osm}-Quelldaten.

Die Rohdaten des Unfallatlas liegen im Quellformat EPSG:25832
(ETRS89\,/\,\acrshort{utm} Zone\,32N) vor. Sie werden jedoch bereits während
der Datenerfassung (Kapitel~\ref{ch:datenerfassung}) automatisch nach EPSG:4326
reprojiziert, sodass EPSG:25832 ausschließlich als Eingangsformat des
Ingestion-Skripts auftritt und im restlichen System nicht mehr in Erscheinung
tritt.

Die Wahl von EPSG:4326 als Datenbankformat in Kombination mit dem PostGIS-Typ
\texttt{GEOGRAPHY} stellt sicher, dass alle Distanzberechnungen korrekt auf dem
\acrshort{wgs84}-Ellipsoid erfolgen -- ohne die Notwendigkeit einer zusätzlichen
Projektion \parencite{postgis_docs}.

\section{REST-APIs und das Client-Server-Modell}

Die Kommunikation zwischen Frontend und Backend erfolgt über eine
\acrfull{rest}-\acrshort{api}. Das Backend stellt HTTP-Endpunkte bereit, die
JSON-formatierte Anfragen entgegennehmen und Antworten zurückgeben.
Dieses zustandslose Architekturmuster ermöglicht eine klare Trennung von
Darstellungs- und Geschäftslogik sowie eine einfache Skalierbarkeit
\parencite{fastapi_docs}. Die \acrshort{api} ist öffentlich erreichbar unter
\url{https://bremen-livability-backend.onrender.com}; eine interaktive
Swagger-Dokumentation steht unter \texttt{/docs} zur Verfügung.
Abbildung~\ref{fig:client_server} zeigt den Kommunikationsfluss.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
    box/.style={draw, rounded corners, minimum width=2.6cm,
                minimum height=1.0cm, align=center, font=\small},
    client/.style={box, fill=NavyBlue!12},
    server/.style={box, fill=OliveGreen!15},
    db/.style={box, fill=Orange!12},
    arr/.style={-{Stealth[length=5pt]}, thick}
  ]
    \node[client] at (0, 0)    (fe) {Flutter App\\(Frontend)};
    \node[server] at (5.5, 0)  (be) {FastAPI\\(Backend)};
    \node[db]     at (11, 0)   (db) {PostGIS\\(Datenbank)};

    \draw[arr] ([yshift= 3pt]fe.east)  -- node[above, font=\scriptsize] {JSON-Request} ([yshift= 3pt]be.west);
    \draw[arr] ([yshift=-3pt]be.west)  -- node[below, font=\scriptsize] {JSON-Response} ([yshift=-3pt]fe.east);
    \draw[arr] ([yshift= 3pt]be.east)  -- node[above, font=\scriptsize] {SQL / ST\_DWithin} ([yshift= 3pt]db.west);
    \draw[arr] ([yshift=-3pt]db.west)  -- node[below, font=\scriptsize] {GeoJSON} ([yshift=-3pt]be.east);
  \end{tikzpicture}
  \caption{Client-Server-Kommunikation über die REST-API}
  \label{fig:client_server}
\end{figure}

\section{Das BLoC-Design-Pattern}
\label{sec:bloc_pattern}

Das \acrfull{bloc}-Design-Pattern \parencite{flutter_bloc} trennt in Flutter-
Anwendungen die UI-Schicht von der Geschäftslogik: Die Benutzeroberfläche sendet
\textit{Events} an den BLoC, der diese verarbeitet und neue \textit{States}
emittiert. Die UI reagiert reaktiv auf Zustandsänderungen. In Kombination mit
dem \texttt{Freezed}-Code\-generator entstehen typsichere, unveränderliche
(\textit{immutable}) Zustandsobjekte, die eine vorhersagbare
Zustandsverwaltung gewährleisten.
Abbildung~\ref{fig:bloc_pattern} veranschaulicht diesen Kreislauf.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
    box/.style={draw, rounded corners, minimum width=2.8cm,
                minimum height=1.0cm, align=center, font=\small},
    ui/.style={box, fill=NavyBlue!12},
    bloc/.style={box, fill=OliveGreen!15},
    state/.style={box, fill=Orange!12},
    arr/.style={-{Stealth[length=5pt]}, thick}
  ]
    \node[ui]    at (0, 0)   (uinode) {UI\\(Widget)};
    \node[bloc]  at (4.5, 0) (blocnode) {BLoC\\(Geschäftslogik)};
    \node[state] at (4.5, -2.5) (statenode) {State\\(\texttt{Freezed})};

    \draw[arr] (uinode.east) -- node[above, font=\scriptsize] {Event} (blocnode.west);
    \draw[arr] (blocnode.south) -- node[right, font=\scriptsize] {emittiert} (statenode.north);
    \draw[arr] (statenode.west) -- node[below, font=\scriptsize] {reaktives Rebuild} (uinode.south east);
  \end{tikzpicture}
  \caption{BLoC-Pattern: Event-State-Kreislauf}
  \label{fig:bloc_pattern}
\end{figure}
