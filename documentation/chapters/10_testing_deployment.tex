% !TEX root = ../main.tex
% ============================================================
\chapter{Testing und Deployment}
\label{ch:testing}
% ============================================================

Dieses Kapitel beschreibt die Qualitätssicherung durch automatisierte Tests
sowie die \acrfull{ci}-Pipeline und die Deployment-Strategie.

\section{Backend-Tests}
\label{sec:backend_tests}

Das Backend wird mit \textbf{pytest} \parencite{pytest_docs} getestet. Die
Testdateien befinden sich im Verzeichnis \texttt{backend/tests/} und decken
vier Bereiche ab:

\begin{table}[H]
      \centering
      \caption{Backend-Testdateien und Testumfang}
      \label{tab:backend_tests}
      \begin{tabularx}{\textwidth}{lrX}
            \toprule
            \textbf{Datei} & \textbf{Tests}                                                & \textbf{Schwerpunkt} \\
            \midrule
            \texttt{test\_scoring.py}
                           & 58
                           & Alle Scoring-Funktionen: Grenzwerte, Rand\-fälle (0, 1, viele
            Objekte), logarithmische Skalierung, binäre Faktoren,
            Importance-Multiplikatoren                                                                            \\
            \texttt{test\_api.py}
                           & --
                           & FastAPI-Endpunkt-Tests mit \texttt{TestClient}                                       \\
            \texttt{test\_database.py}
                           & --
                           & Datenbank-Verbindungstests                                                           \\
            \texttt{test\_main.py}
                           & --
                           & Integrationstests der Hauptanwendung                                                 \\
            \bottomrule
      \end{tabularx}
\end{table}

Die Scoring-Tests sind besonders umfangreich, da der Bewertungsalgorithmus
das Kernstück der Anwendung bildet. Jede der 20 Berechnungsfunktionen wird
mit mindestens den folgenden Szenarien getestet:

\begin{itemize}
      \item \textbf{Leereingabe}: $n = 0$ muss Score $0{,}0$ ergeben.
      \item \textbf{Einzelner Treffer}: Korrektheit der Formeln bei $n = 1$.
      \item \textbf{Sättigungsfall}: Sehr hohe $n$-Werte dürfen das jeweilige
            Maximum nicht überschreiten.
      \item \textbf{Binäre Faktoren}: \texttt{True}/\texttt{False} muss exakt
            die definierte Strafe bzw.\ $0{,}0$ ergeben.
\end{itemize}

\subsection{Code Coverage}

Die Testabdeckung wird mit \texttt{pytest-cov} gemessen und an
Codecov \parencite{codecov} übermittelt. Das Projekt erreicht eine
Abdeckung von über 90\,\%.

\section{Frontend-Tests}
\label{sec:frontend_tests}

Die Flutter-Tests befinden sich in \texttt{frontend/bli/test/} und verwenden
die Bibliotheken \texttt{bloc\_test}, \texttt{mockito} und \texttt{mocktail}
für BLoC-Tests mit gemockten Abhängigkeiten. Getestet werden insbesondere:

\begin{itemize}
      \item \textbf{BLoC-Logik}: Korrekte Zustandsübergänge bei
            Events (z.\,B.\ \path{MapTapped} $\rightarrow$
            \path{MapLoading} $\rightarrow$ \path{MapLoaded})
      \item \textbf{Fehlerbehandlung}: Netzwerkfehler und ungültige
            Serverantworten
      \item \textbf{Authentifizierung}: Login-Flows für verschiedene Provider
\end{itemize}

\section{Continuous Integration}
\label{sec:ci}

Die \acrshort{ci}-Pipeline basiert auf \textbf{GitHub Actions}
\parencite{github_actions} und umfasst drei Workflows:

\begin{table}[H]
      \centering
      \caption{GitHub-Actions-Workflows}
      \label{tab:workflows}
      \begin{tabularx}{\textwidth}{lX}
            \toprule
            \textbf{Workflow} & \textbf{Beschreibung}                                           \\
            \midrule
            \texttt{backend-tests.yml}
                              & Führt \texttt{pytest} bei jedem Push auf das Backend aus;
            übermittelt Coverage an Codecov                                                     \\
            \texttt{frontend-tests.yml}
                              & Führt \texttt{flutter test} bei jedem Push auf das Frontend aus \\
            \texttt{build-release.yml}
                              & Baut APK- (Android), Windows-, macOS- und Linux-Binaries und
            erstellt automatisch GitHub Releases                                                \\
            \bottomrule
      \end{tabularx}
\end{table}

\section{Deployment}
\label{sec:deployment_detail}

Die Infrastruktur (Render.com, Neon.tech, Firebase) ist in
Kapitel~\ref{sec:deployment} beschrieben. Dieser Abschnitt fokussiert auf den
automatisierten Ablauf vom Commit bis zur Produktivschaltung.

Bei jedem Push oder Merge auf \texttt{master} werden vier unabhängige
Prozesse parallel ausgelöst:

\begin{enumerate}
      \item \textbf{Backend-Tests}: \texttt{backend-tests.yml} führt
            \texttt{pytest} mit einer PostGIS-Service-Instanz aus und
            übermittelt die Coverage an Codecov (Flag: \texttt{backend}).
            Wird nur bei Änderungen unter \texttt{backend/} getriggert.
      \item \textbf{Frontend-Tests}: \texttt{frontend-tests.yml} führt
            \texttt{flutter test -{}-coverage} und \texttt{flutter analyze}
            aus und übermittelt die Coverage ebenfalls an Codecov
            (Flag: \texttt{frontend}). Wird nur bei Änderungen unter
            \texttt{frontend/} getriggert.
      \item \textbf{Web-Deployment}: Render.com erkennt den Merge über einen
            GitHub-Webhook und deployt zwei unabhängige Services --
            unabhängig von den Testergebnissen:
            \begin{itemize}
                  \item \textbf{Backend}: Docker-Rebuild des FastAPI-Servers
                        im Verzeichnis \texttt{backend/} (Region: Frankfurt).
                  \item \textbf{Frontend}: Statische Site, gebaut durch
                        \texttt{render\_build.sh}
                        (\texttt{flutter build web -{}-release}); das
                        Ergebnis in \texttt{build/web} wird als Static~Site
                        mit SPA-Rewrite veröffentlicht.
            \end{itemize}
      \item \textbf{Native Builds}: \texttt{build-release.yml} wird durch den
            \emph{erfolgreichen} Abschluss von \texttt{frontend-tests.yml}
            getriggert (\texttt{workflow\_run}) und baut APK- (Android),
            Windows-, macOS- und Linux-Binaries, die als einheitliches
            GitHub~Release veröffentlicht werden
            (vgl.\ Tabelle~\ref{tab:workflows}).
\end{enumerate}

Abbildung~\ref{fig:cicd_pipeline} fasst den Ablauf visuell zusammen.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
    box/.style={draw, rounded corners, minimum width=3.2cm,
                minimum height=1.0cm, align=center, font=\small},
    trigger/.style={box, fill=gray!15, minimum width=4.0cm},
    test/.style={box, fill=NavyBlue!12},
    deploy/.style={box, fill=OliveGreen!15},
    codecov/.style={box, fill=Orange!12},
    arr/.style={-{Stealth[length=5pt]}, thick}
  ]
    % Row 0: Trigger
    \node[trigger] at (0, 0) (push)
      {Push / Merge auf \texttt{master}};

    % Row 1: Three columns
    \node[test]   at (-5, -2.5) (bt) {\texttt{backend-tests.yml}};
    \node[deploy] at ( 0, -2.5) (render)
      {Render.com (Webhook)\\[2pt]
       {\scriptsize Backend: Docker}\\[-1pt]
       {\scriptsize Frontend: Static Site}};
    \node[test]   at ( 5, -2.5) (ft) {\texttt{frontend-tests.yml}};

    % Row 2: Outcomes
    \node[codecov] at (-5, -5.0) (cov1) {Codecov\\(\texttt{backend})};
    \node[codecov] at ( 8, -5.0) (cov2) {Codecov\\(\texttt{frontend})};

    % Row 3: Build release
    \node[deploy] at ( 5, -7.5) (release)
      {\texttt{build-release.yml}\\GitHub Release (4 Plattf.)};

    % Arrows
    \draw[arr] (push) -- (bt);
    \draw[arr] (push) -- (render);
    \draw[arr] (push) -- (ft);
    \draw[arr] (bt)   -- (cov1);
    \draw[arr] (ft)   -- (cov2);
    \draw[arr] (ft)   -- (release);
  \end{tikzpicture}
  \caption{CI/CD-Pipeline: Drei unabhängige Pfade nach dem Merge}
  \label{fig:cicd_pipeline}
\end{figure}
